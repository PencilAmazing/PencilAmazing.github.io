---
layout: post
title: Selecting texture per face in raylib
subtitle: Simple shader and some code for raylib
tags: raylib
published: true
---

Assuming the cube's been generated by `GenMeshCube()`, raylib should create a mesh with normals. Based on these normals, a vertex shader could pass a flat flag to the fragment shader, indicating which texture to sample

**wall.vert:**
```
#version 330

in vec3 vertexPosition;
in vec2 vertexTexCoord;
in vec3 vertexNormal;

out vec2 fragTexCoord;
flat out int face;

uniform mat4 mvp;

void main()
{
    fragTexCoord = vertexTexCoord;
    face = -1;
    if(vertexNormal.x > 0) {
    face = 0;
    } else if(vertexNormal.x < 0) {
    face = 1;
    } else if(vertexNormal.y > 0) {
    face = 2;
    } else if(vertexNormal.y < 0) {
    face = 3;
    } else if(vertexNormal.z > 0) {
    face = 4;
    } else if(vertexNormal.z < 0) {
    face = 5;
    };
    gl_Position = mvp*vec4(vertexPosition, 1.0);
}
```
**wall.frag:**
```
#version 330

in vec2 fragTexCoord;

flat in int face;
out vec4 finalColor;      

uniform sampler2D front;
uniform sampler2D top;
uniform sampler2D bottom;
uniform sampler2D back;
uniform sampler2D right;

uniform sampler2D left;

void main()
{   
    switch(face) {
    case 0: // right
    finalColor = texture(right, fragTexCoord);
    break;
    case 1: // left
    finalColor = texture(left, fragTexCoord);
    break;
    case 2: // top
    finalColor = texture(top, fragTexCoord);
    break;
    case 3: // bottom
    finalColor = texture(bottom, fragTexCoord);
    break;
    case 4: // back
    finalColor = texture(back, fragTexCoord);
    break;
    case 5:
    finalColor = texture(front, fragTexCoord);
    break;
    default:
    finalColor = vec4(1,0,0,1);
    }
    return;
}
```

### Uploading textures
The tricky part here is uploading the textures to be used by the GPU. I'm using raylib-cs, which gives simple C# bindings to the raylib dll. Things can be a bit more difficult 

When loading textures, note down the locations of each sampler in the shader
```
WallShader = LoadShader(AssetShaderPrefix + "wall.vert", AssetShaderPrefix + "wall.frag");
rightloc = GetShaderLocation(WallShader, "right");
leftloc = GetShaderLocation(WallShader, "left");
toploc = GetShaderLocation(WallShader, "top");
bottomloc = GetShaderLocation(WallShader, "bottom");
backloc = GetShaderLocation(WallShader, "back");
frontloc = GetShaderLocation(WallShader, "front");
```

Then, for each texture you upload it to the GPU via the material then bind the texture to the shader:
```
// In case you didn't notice, I'm using C# bindings
unsafe {
	// Assign textures to locations
	cache.wallMaterial.shader.locs[(int)ShaderLocationIndex.SHADER_LOC_MAP_DIFFUSE + 0] = cache.toploc;
	cache.wallMaterial.shader.locs[(int)ShaderLocationIndex.SHADER_LOC_MAP_DIFFUSE + 1] = cache.leftloc;
	cache.wallMaterial.shader.locs[(int)ShaderLocationIndex.SHADER_LOC_MAP_DIFFUSE + 2] = cache.frontloc;
	cache.wallMaterial.shader.locs[(int)ShaderLocationIndex.SHADER_LOC_MAP_DIFFUSE + 3] = cache.bottomloc;
	cache.wallMaterial.shader.locs[(int)ShaderLocationIndex.SHADER_LOC_MAP_DIFFUSE + 4] = cache.rightloc;
	cache.wallMaterial.shader.locs[(int)ShaderLocationIndex.SHADER_LOC_MAP_DIFFUSE + 5] = cache.backloc;

	// Assign textures to shader
	cache.wallMaterial.maps[0].texture = tex.top.texture;
	cache.wallMaterial.maps[1].texture = tex.left.texture;
	cache.wallMaterial.maps[2].texture = tex.front.texture;
	cache.wallMaterial.maps[3].texture = tex.bottom.texture;
	cache.wallMaterial.maps[4].texture = tex.right.texture;
	cache.wallMaterial.maps[5].texture = tex.back.texture;
}
DrawMesh(cache.cube, cache.wallMaterial, translate);
```
