---
layout: post
title: "Selecting texture per face"
subtitle: "Simple shader and some code for raylib"
tags: raylib
---

Assuming the cube's been generated by `GenMeshCube()`, raylib should create a mesh with normals. Based on these normals, a vertex shader could pass a flat flag to the fragment shader, indicating which texture to sample

**wall.vert:**
```
#version 330

in vec3 vertexPosition;
in vec2 vertexTexCoord;
in vec3 vertexNormal;

out vec2 fragTexCoord;
flat out int face;

uniform mat4 mvp;

void main()
{
    fragTexCoord = vertexTexCoord;
    face = -1;
    if(vertexNormal.x > 0) {
    face = 0;
    } else if(vertexNormal.x < 0) {
    face = 1;
    } else if(vertexNormal.y > 0) {
    face = 2;
    } else if(vertexNormal.y < 0) {
    face = 3;
    } else if(vertexNormal.z > 0) {
    face = 4;
    } else if(vertexNormal.z < 0) {
    face = 5;
    };
    gl_Position = mvp*vec4(vertexPosition, 1.0);
}
```
**wall.frag:**
```
#version 330

in vec2 fragTexCoord;

flat in int face;
out vec4 finalColor;      

uniform sampler2D front;
uniform sampler2D top;
uniform sampler2D bottom;
uniform sampler2D back;
uniform sampler2D right;

uniform sampler2D left;

void main()
{   
    switch(face) {
    case 0: // right
    finalColor = texture(right, fragTexCoord);
    break;
    case 1: // left
    finalColor = texture(left, fragTexCoord);
    break;
    case 2: // top
    finalColor = texture(top, fragTexCoord);
    break;
    case 3: // bottom
    finalColor = texture(bottom, fragTexCoord);
    break;
    case 4: // back
    finalColor = texture(back, fragTexCoord);
    break;
    case 5:
    finalColor = texture(front, fragTexCoord);
    break;
    default:
    finalColor = vec4(1,0,0,1);
    }
    return;
}
```

### Uploading textures
The tricky part here is uploading the textures to be used by the GPU. I'm using raylib-cs, which gives simple C# bindings to the raylib dll. Things can be a bit more difficult 

When loading textures, note down the locations of each sampler in the shader
```
WallShader = LoadShader(AssetShaderPrefix + "wall.vert", AssetShaderPrefix + "wall.frag");
rightloc = GetShaderLocation(WallShader, "right");
leftloc = GetShaderLocation(WallShader, "left");
toploc = GetShaderLocation(WallShader, "top");
bottomloc = GetShaderLocation(WallShader, "bottom");
backloc = GetShaderLocation(WallShader, "back");
frontloc = GetShaderLocation(WallShader, "front");
```

Then, for each texture you upload it to the GPU via the material then bind the texture to the shader:
```
SetMaterialTexture(ref cache.wallMaterial, (MaterialMapIndex)0, cache.tiles[tex.top]);
SetMaterialTexture(ref cache.wallMaterial, (MaterialMapIndex)1, cache.tiles[tex.left]);
SetMaterialTexture(ref cache.wallMaterial, (MaterialMapIndex)3, cache.tiles[tex.bottom]);
SetMaterialTexture(ref cache.wallMaterial, (MaterialMapIndex)2, cache.tiles[tex.front]);
SetMaterialTexture(ref cache.wallMaterial, (MaterialMapIndex)4, cache.tiles[tex.right]);
SetMaterialTexture(ref cache.wallMaterial, (MaterialMapIndex)5, cache.tiles[tex.back]);

SetShaderValueTexture(cache.wallMaterial.shader, cache.toploc, cache.tiles[tex.top]);
SetShaderValueTexture(cache.wallMaterial.shader, cache.leftloc, cache.tiles[tex.left]);
SetShaderValueTexture(cache.wallMaterial.shader, cache.frontloc, cache.tiles[tex.front]);
SetShaderValueTexture(cache.wallMaterial.shader, cache.bottomloc, cache.tiles[tex.bottom]);
SetShaderValueTexture(cache.wallMaterial.shader, cache.rightloc, cache.tiles[tex.right]);
SetShaderValueTexture(cache.wallMaterial.shader, cache.backloc, cache.tiles[tex.back]);

DrawMesh(cache.cube, cache.wallMaterial, translate);
```